/* AVOID THE UNICODE FORMAT! !NOTE! AVOID THE UNICODE FORMAT! */
/* AVOID THE UNICODE FORMAT! !NOTE! AVOID THE UNICODE FORMAT! */
/* AVOID THE UNICODE FORMAT! !NOTE! AVOID THE UNICODE FORMAT! */
/* AVOID THE UNICODE FORMAT! !NOTE! AVOID THE UNICODE FORMAT! */
/// \file tcpcat_api.h
/// \mainpage
/// @{
/// \section attention Предупреждение
/// \b ВНИМАНИЕ! Файл <b>"tcpcat_api.h"</b> распространяется под авторским правом РАЗРАБОТЧИКА данного файла.
/// Любые изменения в данном файле СТОРОННИМИ разработчиками НЕДОПУСТИМЫ.
/// Для использования данного файла просто включите его в проект с помощью директивы #include.
///
/// \section common Общие требования к плагинам
///   - плагины должны быть выполнены в виде динамически исполняемых библиотек (DLL)
///   - DLL-модули могут иметь любое имя и расширение ".dll"
///   - DLL-модули должны быть расположены в каталоге "<каталог EXE-модуля>\plugins" или
///       в его подкаталогах любого уровня вложения
///   - функции, экспортируемые библиотекой, должны иметь недекорируемые (naked) имена
///   - функции, экспортируемые библиотекой, должны поддерживать MSCU_CALL_PREFIX - stdcall (__stdcall) соглашение о вызове
///
/// \section changelog Изменения
/// - [+] 2017-08-30 - Добавлено - флаги DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3 (см. документацию);
/// - [*] 2017-07-26 - Изменено: обновлено описание функции Tplug_callback_srm_unfreeze (см. документацию);
/// - [+] 2017-06-17 - Добавлено - функции - plug_callback_srm_add_spy_ex, plug_callback_srm_add_spy_ipv6_ex (см. документацию)
/// - [+] 2017-06-02 - Добавлено - функция plug_callback_complex_teri_make_urgent (см. документацию);
/// - [+] 2017-06-02 - Добавлено - функция plug_callback_complex_teri_match (см. документацию)
/// - [-] 2017-02-15 - Исправлено - ошибки в документации;
/// - [+] 2016-12-21 - Добавлено - функция - plug_callback_srm_add_spy_ipv6 (см. документацию)
/// - [+] 2016-11-16 - Добавлено - функция plug_callback_srm_set_secondary_token2 (см. документацию)
/// - [+] 2016-11-13 - Добавлено - функция Tplug_callback_sid_tokens_clone
/// - [+] 2016-03-14 - Добавлено - поддержка TOKEN-атрибутов для функций Tplug_callback_register_data_XXX (см. документацию)
/// - [+] 2015-11-19 - Добавлено - TCatSID - поддержка типов портов;
/// - [+] 2015-06-01 - Добавлено - поддержка кодировки UTF-8 в значениях атрибутов;
/// - [+] 2015-02-17 - добавлено: флаг PERFORM_COMMAND_BIND для функции Ttcpcat_plug_perform (см. документацию)
/// - [+] 2015-02-17 - добавлено: флаг PERFORM_COMMAND_BUILD для функции Ttcpcat_plug_perform (см. документацию)
/// - [+] 2015-02-17 - Добавлено: функция plug_callback_register_field_info (см. документацию)
/// - [+] 2014-07-30 - Добавлено: функция plug_callback_register_data_svc_tv (см. документацию)
/// - [*] 2014-07-18 - Изменено: карта меток времени в буфере buf при вызове plug_session_data за картой направлений (см. документацию);
/// - [*] 2014-07-18 - Изменено: карта направлений в буфере buf при вызове plug_session_data теперь может быть модифицирована обработчиком (см. документацию);
/// - [+] 2014-06-27 - Добавлено: функция plug_callback_register_data_svc (см. документацию)
/// - [+] 2014-04-23 - Добавлено: функция plug_callback_find_field_info (см. документацию)
/// - [*] 2014-02-27 - Добавлено: карта направлений в буфере buf при вызове plug_session_data (см. документацию);
/// - [*] 2014-01-17 - Изменено: функция plug_callback_teri_match считается устаревшей;
/// - [+] 2012-12-25 - добавлено - функция plug_callback_srm_set_secondary_token (см. документацию)
/// - [+] 2012-06-15 - добавлено - атрибут PROTOCOL параметра data_attrs функции plug_callback_register_data
/// - [+] 2012-05-02 - добавлено - функция plug_callback_file_read (см. документацию)
/// - [*] 2011-08-12 - изменено - использование константы TCPCAT_RESULT_CROP_AND_NEED_BASE в алгоритме работы plug_session_data (см. документацию)
/// - [*] 2011-08-12 - изменено - алгоритм работы plug_session_data при возвращаемом значении TCPCAT_RESULT_SKIP_ALL (см. документацию)
/// - [*] 2011-08-12 - изменено - вызов plug_session_data со значениями параметров buf==0,len<0,flags(-DD_FLAGS_FIXED_DATA) (см. документацию = "Особые случаи")
/// - [*] 2011-08-12 - изменено - вызов plug_session_data со значениями параметров buf==0,len==0,flags(+DD_FLAGS_FIXED_DATA) (см. документацию = "Особые случаи")
/// - 2011-05-31 - изменено - функция plug_callback_srm_teri_match - режим уточняющего отбора (см. документацию)
/// - 2011-01-07 - изменено - комментарии к режиму работы plug_callback_srm_unfreeze (см. документацию)
/// - 2010-09-20 - добавлено - alt_ports - порты исключения (см. документацию)
/// - 2010-09-16 - добавлено - функция plug_callback_srm_teri_match_tag (см. документацию)
/// - 2010-09-16 - добавлено - функция plug_callback_srm_set_tag (см. документацию)
/// - 2010-09-13 - изменено - режим работы plug_session_data (см. документацию)
/// - 2010-06-25 - добавлено - новый тип данных - DD_PDT_ISTAT - статистические данные (идентификационная информация);
/// - 2010-06-02 - добавлено - новый тип данных - DD_PDT_STAT - статистические данные;
/// - 2010-05-24 - переход в однопоточный режим работы
/// - 2010-05-23 - функция - plug_callback_file_close - реализована
/// - 2010-05-23 - функция - plug_callback_file_write - реализована
/// - 2010-05-23 - функция - plug_callback_file_create - реализована
/// - 2010-04-19 - изменено - параметры вызова функции plug_callback_register_data (см. документацию)
/// - 2010-04-19 - изменено - значения констант DD_XXX
/// - 2010-04-19 - удалено: флаги DD_SOURCE_FILE, DD_DO_UNLINK (заменены флагами SWINE_DATA_BUFFER_XXX)
/// - 2010-04-19 - удалено: константы MT_XXX (типы сообщений) - определены в mscu_types.h
/// - 2010-02-24 - удалено: функции prefs_XXX из структуры TTCPCATStandartFunctions (используйте одноименные функции из prefs.h)
/// - 2010-02-24 - удалено: функция tcpcat_plug_config_dialog (используйте tcpcat_plug_config_register)
/// - 2010-02-24 - удалено: функция tcpcat_plug_config_save (используйте tcpcat_plug_config_register)
/// - 2010-02-24 - удалено: функция tcpcat_plug_config_load (используйте tcpcat_plug_config_register)
/// - 2010-02-24 - изменено: тип возвращаемого значения функции tcpcat_plug_perform
/// - 2010-02-24 - удалено: функция tcpcat_plug_idle (используйте tcpcat_plug_perform(PERFORM_COMMAND_IDLE))
/// - 2010-02-24 - удалено: функция tcpcat_plug_stop (используйте tcpcat_plug_perform(PERFORM_COMMAND_STOP))
/// - 2010-02-24 - удалено: функция tcpcat_plug_start (используйте tcpcat_plug_perform(PERFORM_COMMAND_START))
/// - 2010-02-24 - добавлено: флаг PERFORM_COMMAND_START для функции Ttcpcat_plug_perform
/// - 2010-02-24 - добавлено: флаг PERFORM_COMMAND_STOP для функции Ttcpcat_plug_perform
/// - 2010-02-24 - добавлено: флаг PERFORM_COMMAND_IDLE для функции Ttcpcat_plug_perform
/// - 2010-02-24 - добавлено: флаг PERFORM_COMMAND_FLUSH для функции Ttcpcat_plug_perform
/// - 2010-02-15 - незначительные изменения типов
/// - 2010-02-03 - тип TCatSID::reserved заменен с unsigned long в gpointer
/// - 2010-02-03 - тип Tplug_perform переименован в Ttcpcat_plug_perform
/// - 2010-02-01 - изменено поведение data_cache_block_remove
/// - 2009-11-06 - обновлено - описание plug_callback_register_data (TCPCAT_RESULT_SKIP_ALL, TCPCAT_RESULT_SKIP_BASE) (см. документацию)
/// - 2009-09-19 - добавлена функция - plug_callback_srm_make_urgent (см. документацию)
/// - 2009-09-19 - добавлена функция - plug_callback_srm_add_spy (см. документацию)
/// - 2009-09-19 - добавлена функция - plug_callback_srm_unfreeze (см. документацию)
/// - 2009-09-19 - добавлена функция - plug_callback_srm_freeze (см. документацию)
/// - 2009-09-19 - добавлена функция - plug_callback_srm_teri_match (см. документацию)
/// - 2009-09-19 - удалены функции prefs_get_tmp_val_XXX-функции
/// - 2009-06-09 - добавлена поддержка IPv6
/// - 2009-04-07 - обновлено - исправлены ошибки в описании plug_callback_register_data (см. документацию)
/// - 2009-03-17 - обновлено - описание plug_callback_register_data (acl_XXX - новый тип данных) (см. документацию)
/// - 2009-02-17 - plug_callback_register_data - data_attrs - адреса IP/PORT(src/dest), содержащиеся в sid, не прописываются
///              (автоматически встпавляются сервером)
/// - 2009-02-12 - добавлена функция - plug_callback_file_close (см. документацию)
/// - 2009-02-12 - добавлена функция - plug_callback_file_write (см. документацию)
/// - 2009-02-12 - добавлена функция - plug_callback_file_create (см. документацию)
/// - 2009-02-12 - plug_callback_sid_clone - добавлены параметры: stuff
/// - 2009-02-12 - plug_callback_sid_free - добавлены параметры: stuff
/// - 2009-02-11 - plug_register - добавлены параметры: alt_ports, alt_tokens
/// - 2009-02-11 - обновлено - описание plug_session_data
/// - 2009-01-28 - удалены флаги DD_DO_NOT_CREATE_CONTEXT и DD_ALWAYS_CREATE_CONTEXT
/// - 2009-01-28 - обновлено - параметр shandle (функция Tplug_session_data) передается по ссылке
/// - 2009-01-28 - обновлено - описание возвращаемого значения Tplug_session_data
/// - 2009-01-27 - обновлено - алгоритм работы
/// - 2009-01-27 - добавлено - Tplug_setup_flags
/// - 2009-01-27 - добавлено - TCPCAT_RESULT_ESCAPE
/// - 2009-01-27 - добавлено - prefs_XXX-функции
/// - 2009-01-12 - Tplug_callback_register_data - добавлено описание регистрации аутентификационной информации
/// - 2009-01-12 - char* -> const char* (c++)
/// - 2008-12-19 - изменено поведение функции plug_session_data (закрытие контекста обработки - см. описание)
/// - 2008-12-10 - добавлено - prefs_XXX-функции
/// - 2008-10-24 - Tplug_callback_register_data - добавлены data_ct, data_of, изменены data_attrs
///
/// \section copyright Авторские права
/// Copyright (C) MSC, ORG 2006-2017
///
/// @}
#ifndef TCPCAT_PLUG_IF_INC
/// \cond
#define TCPCAT_PLUG_IF_INC
/// \endcond

#include "mscu_types.h"
#include <limits.h>
#include <prefs/prefs.h>
#include <teri_bis/teri_bis.h>
#include "swine_api.h"

/// \page Algorithm Алгоритм работы сервера плагинов
/// @{
///
/// 1. После запуска сервер сканирует подкаталог "plugins" каталога, где расположен exe-файл (включая
///    подкаталоги), на предмет наличия dll-файлов с расширением ".dll". Очередной найденный файл
///    загружается и в нем проверяется наличие определенных экспортируемых функций
///      - tcpcat_plug_register - тип \ref Tplug_register
///      - tcpcat_plug_unregister - тип \ref Tplug_unregister
///      - tcpcat_plug_config_register - тип \ref Tplug_config_register (не обязательно)
///      - tcpcat_plug_setup_flags - тип \ref Tplug_setup_flags    (не обязательно)
///      - tcpcat_plug_session_begin - тип \ref Tplug_session_begin
///      - tcpcat_plug_session_data - тип \ref Tplug_session_data
///      - tcpcat_plug_session_end - тип \ref Tplug_session_end
///      - tcpcat_plug_perform - тип \ref Ttcpcat_plug_perform
///      .
/// Далее:
///      Вызывается функция \b tcpcat_plug_register. Если функция возвратила нулевое значение (успех),
///      плагин заносится в список плагинов-обработчиков сервера. В случае неудачи модуль выгружается.
///
/// 2. После загрузки всех плагинов для каждого вызывается функция \b tcpcat_plug_config_register, предлагая плагину
///    зарегистрировать свои параметры работы (загрузка, модификация и сохрание параметров осуществляются вызывающим приложением).
///
/// 3. При изменении параметров работы системы (настройки параметров работы сервера) для каждого из плагинов
///    могут быть изменены параметры, зарегистрированные функцией tcpcat_plug_config_register
///    для вывода диалога изменения параметров. Диалог
///    изменения параметров должен полностью контролироваться (создаваться, удаляться) самим плагином.
///    Сервер не накладывает никаких ограничений на вид, струтуру и поведение данного диалога.
///
/// 4. Перед началом процесса обработки:
///     - Для каждого плагина-обработчика вызывается функция \b tcpcat_plug_perform(PERFORM_COMMAND_START) (для инициализации
///       внутренних структур).
///     - Для каждого плагина-обработчика вызывается функция \b tcpcat_plug_setup_flags (для установки
///       началных значений флагов).
///
/// 5. Процесс обработки.
///     - В процессе обработки при открытии очередной сессии поочередно для каждого плагина вызывается функция
///       \b tcpcat_plug_session_begin, предлагая плагину принять сессию на обработку. Первый плагин, вернувший
///       ненулевое значение контекста обработки, считается обработчиком данной сессии и дальнейший проход
///       не производится.
///       Новый режим работы - поиск плагина-обработчика для сессии осуществляется без вызова функции
///       \b tcpcat_plug_session_begin. В этом случае при первом вызове функции \b tcpcat_plug_session_data для
///       данной сессии плагину необходимо создать контекст обработки.
///     - В процессе обработки, при поступлении очередных данных в рамках определенной сессии,
///       вызывается функция \b tcpcat_plug_session_data
///       соответствующего плагина с соответствующим контекстом обработки.
///     - В процессе обработки, при завершении определенной сессии, вызывается функция \b tcpcat_plug_session_end
///       соответствующего плагина с соответствующим контекстом обработки для выполнения заключительных этапов
///       обработки и закрытия ресурсов.
///     - В процессе обработки, когда входящая очередь пакетов пуста, с определенной
///       периодичностью (порядка 1 сек или 100 мсек) может вызываться функция \b tcpcat_plug_perform(PERFORM_COMMAND_IDLE), в которой плагин-обработчик может
///       выполнять фоновые операции.
///     - В процессе обработки может вызываться функция \b tcpcat_plug_perform, в которой плагин-обработчик должен
///       выполнять требуемые действия.
///     - С помощью klogf(msculib) или Callback-функции \b plug_callback_add_message плагин-обработчик может послать сообщение серверу
///       для вывода его на экран пользователю. Сообщения могут быть различных типов: информация (MT_INFORMATION),
///       ошибка (MT_ERROR) и предупреждение (MT_WARNING).
///     - С помощью Callback-функции \b plug_callback_register_data плагин-обработчик может зарегистрировать определенный
///       блок выходных данных. Данные могут быть различного типа.
///     - С помощью Callback-функции \b plug_callback_teri_match плагин-обработчик может произвести отбор обрабатываемых
///       данных. Данные, не прошедшие отбор, исключаются из дальнейшей обработки.
///     - \b Внимание! Сервер ГАРАНТИРУЕТ, что вызов функций \b tcpcat_plug_session_begin, \b tcpcat_plug_session_data,
///       \b tcpcat_plug_session_end и \b tcpcat_plug_perform(PERFORM_COMMAND_IDLE) для каждого плагина будет происходить синхронно, т.е.
///       в один и тот же момент времени будет выполняться только одна функция (без взаимных наложений)
///
/// 6. После завершения процесса обработки:
///     - для каждого плагина-обработчика вызывается функция \b tcpcat_plug_perform(PERFORM_COMMAND_FLUSH) - для "мягкого" завершения.
///     - для каждого плагина-обработчика вызывается функция \b tcpcat_plug_perform(PERFORM_COMMAND_STOP) - для "грубого" завершения.
///
/// 7. Перед выгрузкой всех плагинов (перед завершением работы приложения-сервера) для каждого вызывается функция
///    \b tcpcat_plug_unregister для корректного освобождения используемых ресурсов.
///
/// @}

/// \defgroup Interface Интерфейс плагина-обработчика
/// @{

/// \name Константы
/// \{

/// размер строкового буфера в байтах
#define TCPCAT_STR_SIZE 16384

/// \}

/// \name Информация о сессии
/// \{

/// тип адреса - IPv4
#define AT_IPv4   2

/// тип адреса - IPv6
#define AT_IPv6   3

/// тип порта - TCP
#define  PT_TCP   2               /* TCP */

/// тип порта - UDP
#define  PT_UDP   3               /* UDP */

/// \struct TCatAddress
/// структура, хранящая IP-адрес
///
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TCatAddress {
  union {
    guint8 in_addr[4];
    guint32 in_addr_d;
    guint16 in6_addr[8];
    guint8  in6_addr_b[16];
  };
};
STRUCT_PACKED_END
/// указатель на структуру TCatSID
typedef TCatAddress* PCatAddress;

/// \struct TCatSID
/// структура, хранящая идентификатор сессии
///
/// \b Внимание!
/// Экземпляр структуры TCatSID, передаваемой в функциях \ref Tplug_session_begin и \ref Tplug_session_data,
/// действителен только во время жизни соответствующей сессии.
/// После вызова функции \ref Tplug_session_end, запрещается использование соответствующего экземпляра структуры.
/// Если существует необходимость использования экземпляра после уничтожения соответствующей ему сессии,
/// следует использовать функции обратного вызова \ref Tplug_callback_sid_clone - для инициализации нового
/// экземпляра-копии и \ref Tplug_callback_sid_free - для уничтожения его после окончания использования.
///
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TCatSID {
  guint8      nettype;  ///< тип IP-адреса (AT_XX)
  guint8      porttype; ///< тип порта (PT_XX)
  guint16     stub;
  TCatAddress saddr;    ///< IP-адрес источника
  TCatAddress daddr;    ///< IP-адрес приемника
  guint16     sport;    ///< TCP-порт источника (host-формат)
  guint16     dport;    ///< TCP-порт приемника (host-формат)
  guint32     pid;      ///< PID
  guint32     lid;      ///< LID
  gpointer reserved;    ///< зарезервировано - указатель на динамические данные - не участвует в подсчете хэш-значения
};
STRUCT_PACKED_END
/// указатель на структуру TCatSID
typedef TCatSID* PCatSID;

/// \struct TCatSessionInfo
/// информация о сессии
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TCatSessionInfo {
  TCatSID sid; ///< идентификатор сессии
  double quality; ///< качество в процентах: 0..100
};
STRUCT_PACKED_END
/// указатель на структуру TCatSID
typedef TCatSessionInfo* PCatSessionInfo;

/// \}

/// \name Коды ошибок (коды возврата функций)
/// \{

/// удачное выполнение операции
#define TCPCAT_ERROR_SUCCESS              0

/// неизвестная ошибка
#define TCPCAT_ERROR_UNKNOWN              -1

/// неверный параметры
#define TCPCAT_ERROR_BAD_PARAMS           -2

/// недостаточно ресурсов
#define TCPCAT_ERROR_OUT_OF_RESOURCES     -3

/// \}

/// \name Флаги обработки
/// \{

/// направление передачи данных:
///  - флаг отсутствует (0) - прямое (или единственное) направление передачи
///  - флаг присутствует (1) - обратное направление передачи (при двусторонней передаче данных)
///
#define DD_DIRECTION_REVERSE    0x0001

/// триггер правил обработки данных:
///  - флаг отсутствует (0) - неограниченные правила обработки данных
///  - флаг присутствует (1) - фиксированные (ограниченные) правила обработки данных
///
#define DD_FIXED_DATA           0x0002

/// !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
/// вид передаваемого буфера данных:
/// используется при задании режима обработки сессии и при обработке данных сессии
///            - флаг отсутствует (0) - данные в буфере от двух направлений "склеиваются" без указаний направления
///            - флаг присутствует (1) - перед каждым блоком данных в буфере располагается заголовок (4 байта - host-формат):
///                          старший бит - 0 - прямое направление / 1 - обратное направление
///                          младшие 31 бит - длина передаваемого блока данных в байтах (размер данного заголовка не учитывается )
///
#define DD_COMPLEX_BUFFER       0x0004

/// !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
/// байтовый заголовок в комплексном буфере
/// используется совместно с флагом DD_COMPLEX_BUFFER
///  - флаг отсутствует (0) - заголовок, передавемый перед блоком данных имеет размер 32 бита / 4 байта (описан выше)
///  - флаг присутствует (1) - заголовок, передавемый перед блоком данных имеет размер 5 байт:
///                          первый байт - 0 - прямое направление / не 0 - обратное направление
///                          последние 4 байта - длина передаваемого блока данных в байтах (host-формат, размер данного заголовка не учитывается)
///
#define DD_COMPLEX_BUFFER_BYTES 0x0008

/// флаг, определяющий долговременность сессии
///  - флаг отсутствует (0) - сессия имеет стандартное время жизни
///                         максимальное время жизни определяется параметром
///                         "Время отсутствия активности сессии"
///  - флаг присутствует (1) - сессия имеет увеличенное время жизни
///                          максимальное время жизни определяется параметром
///                          "Время отсутствия активности длительной сессии"
///
#define DD_LONG_TTL             0x0010

/// флаг, определяющий режим обработки сессии (задается в функции \ref Tplug_session_begin)
///  - флаг отсутствует (0) - сборка сессии в режиме DD_FIXED_DATA (полная сборка, затем передача на обработку)
///  - флаг присутствует (1) - сборка сессии в поточном режиме (по частям)
///                          при вызове функции plug_session_data флаг DD_FIXED_DATA будет присутствовать
///                          только при передаче последнего блока данных сессии
///
#define DD_STREAMED_DATA        0x0020

/// флаг, определяющий тип сессии (передается в функцию \ref Tplug_session_data)
///  - флаг отсутствует (0) - сессия (обрабатываемый блок) состоит из данных только одного направления
///  - флаг присутствует (1) - сессия (обрабатываемый блок) состоит из данных обоих направлений
///
#define DD_TWO_DIRECTIONS       0x0040

/// статистические данные (используется при вызове функции \ref Tplug_cllback_register_data):
///  - флаг отсутствует (0) - регистрируются информационные данные
///  - флаг присутствует (1) - регистрируются статистические данные
///
/// допускается присутствие только одного из флагов DD_PDT_STAT, DD_PDT_ISTAT, DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3
#define DD_PDT_STAT             0x0080

/// статистические данные - идентификационная информация (используется при вызове функции \ref Tplug_cllback_register_data):
///  - флаг отсутствует (0) - регистрируются информационные данные
///  - флаг присутствует (1) - регистрируются статистические данные
///
/// допускается присутствие только одного из флагов DD_PDT_STAT, DD_PDT_ISTAT, DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3
#define DD_PDT_ISTAT            0x0100

/// статистические данные - идентификационная информация (используется при вызове функции \ref Tplug_cllback_register_data):
///  - флаг присутствует (1) - регистрируются статистические данные в формате <2И> (соответствует DD_PDT_ISTAT)
///
/// допускается присутствие только одного из флагов DD_PDT_STAT, DD_PDT_ISTAT, DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3
#define DD_PDT_ISTAT1            0x0100

/// статистические данные - идентификационная информация (используется при вызове функции \ref Tplug_cllback_register_data):
///  - флаг присутствует (1) - регистрируются статистические данные в формате <Приказ 83>
///
/// допускается присутствие только одного из флагов DD_PDT_STAT, DD_PDT_ISTAT, DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3
#define DD_PDT_ISTAT2            0x0200

/// статистические данные - идентификационная информация (используется при вызове функции \ref Tplug_cllback_register_data):
///  - флаг присутствует (1) - регистрируются статистические данные в формате <НТ>
///
/// допускается присутствие только одного из флагов DD_PDT_STAT, DD_PDT_ISTAT, DD_PDT_ISTAT1, DD_PDT_ISTAT2, DD_PDT_ISTAT3
#define DD_PDT_ISTAT3            0x0400

/// \}

/// \name Флаги заголовка сложного буфера (DD_COMPLEX_BUFFER) или карты направлений
/// \{

/// прямое направление - старший бит равен 0
#define CB_DIRECTION_DIRECT   0x00000000

/// обратное направление - старший бит равен 1
#define CB_DIRECTION_REVERSE  0x80000000

/// маска бита прямое/обратное направление - старший бит
#define CB_DIRECTION_MASK  0x80000000

/// битовая маска поля длины блока в заголовке
#define CB_DATA_SIZE_MASK     0x7fffffff

/// \}

/// \struct TDirectionMapItem
/// структура, хранящая элемент карты направлений
///
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TDirectionMapItem {
  guint32 dir:  1;  /* direction - 0 - direct, 1 - reverse; направление - 0 - прямое, 1 - обратное */
  guint32 res: 31;  /* reserved - зарезервировано */
  guint32 len;          /* part length in bytes - длина участка в байтах */
};
STRUCT_PACKED_END
/// указатель на структуру TDirectionMapItem
typedef TDirectionMapItem* PDirectionMapItem;

/// \struct TTimestampMapItem
/// структура, хранящая элемент карты меток времени
///
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TTimestampMapItem {
  Ttimeval tv;          /* timestamp for given part - метка времени для данного участка */
  guint32 len;          /* part length in bytes - длина участка в байтах */
};
STRUCT_PACKED_END
/// указатель на структуру TDirectionMapItem
typedef TTimestampMapItem* PTimestampMapItem;

/// \name Значения, возвращаемые \ref Ttcpcat_session_data
/// \{

#define TCPCAT_RESULT_FINISH                  INT_MIN ///< -2147483648 == 0x80000000  - собрать до конца
#define TCPCAT_RESULT_SKIP_ALL            -2147483647 ///< 0x80000001 - пропустить до конца
#define TCPCAT_RESULT_SKIP_BASE           -1073741824 ///< 0xc0000000 - пропустить следующие (res - TCPCAT_RESULT_SKIP_BASE) байт, где res - возвращаемый результат, больший по модулю TCPCAT_RESULT_SKIP_BASE
#define TCPCAT_RESULT_CROP_AND_NEED_BASE   1073741824 ///< 0x40000000 - обработать (res - TCPCAT_RESULT_SKIP_BASE) байт в буфере и запросить -1 байт к оставшимся в буфере, где res - возвращаемый результат, больший TCPCAT_RESULT_CROP_AND_NEED_BASE
#define TCPCAT_RESULT_DISCARD              2147483647 ///< 0x7fffffff - отказаться
#define TCPCAT_RESULT_ESCAPE               2147483646 ///< 0x7ffffffe - отказаться в пользу другого обработчика

/// \}

/// \defgroup tcpcat_callback Функции обратного вызова
/// \{

/// посылка сообщения серверу обработки
/// !данная функция является устаревшей, используйте msculib::klogf(MT_XXX, "[<название_модуля>] <сообщение>" <параметры>) вместо нее!
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param msg_buf - текстовое сообщение (строка с завершающим нулем)
/// \param msg_type - тип сообщения (константы типа "MT_xxx")
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_add_message)(void * stuff, gconstpchar msg_buf, int msg_type);

/// регистрация данных
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param sid - адресный идентификатор данных (адреса и порты) - передается сервером при вызове функции \ref Tplug_session_begin
/// \param data_flags - набор флагов, определяющих:
///              DD_DIRECTION_REVERSE - задает направление передачи докумета (флаг отсутствует - прямое направление
///                                                                           флаг присутствует - обратное направление)
///              DD_PDT_STAT - статистические данные (флаг отсутствует - регистрируются информационные данные
///                                                   флаг присутствует - регистрируются статистические данные)
///              DD_PDT_ISTAT - статистические данные - идентификационная информация (флаг отсутствует - регистрируются информационные данные
///                                                   флаг присутствует - регистрируются статистические данные)
/// \param data_buf - указатель на буфер данных/имя файла/дескриптор файла (используется совместно с флагами SWINE_DATA_BUFFER_XXX в значении data_len)
/// \param data_len - количество байт в буфере данных/тип буфера (используются значения флагов SWINE_DATA_BUFFER_XXX)
/// \param data_type - расширение типа данных (строка с завершающим нулем), может быть nil
///        пример: "eml"
/// \param data_attrs - атрибуты данных в текстовом виде (строка с завершающим нулем), может быть nil
///              задаются в виде: \code <АТРИБУТ_1>;<АТРИБУТ_2>;...;<АТРИБУТ_N> \endcode
///              значение \c <АТРИБУТ>, содержащее символы "точка с запятой", "двойные кавычки", обрамляется двойными кавычками: \code "<АТРИБУТ>" \endcode.
///              при этом, двойные кавычки, содержащиеся в значении \c <АТРИБУТ>, дублируются: \code "I:MAIL_SUBJECT=subject;""mail delivery""" \endcode
///              допустимы следующие виды атрибутов:
///                - адресная часть (идентификаторы) - IDENTIFIER:
/// \code
///                   I:<ИМЯ>[/<НАПРАВЛЕНИЕ>][/<ПРОТОКОЛ>]=<ЗНАЧЕНИЕ>
/// \endcode
///                     \c <ИМЯ> - название параметра (заглавные символы): IP, PORT <br>
///                     \c <НАПРАВЛЕНИЕ> - CALL или ANSW (принадлежность параметра к прямому или обратному направлению) <br>
///                     \c <ПРОТОКОЛ> - принадлежность параметра к определенному протоколу
///                     \c <ЗНАЧЕНИЕ> - значение параметра (если значение начинается с символов 0xEF,0xBB,0xBF - считается, что кодировка - UTF-8, иначе - WIN1251) <br>
///                   пример: \code "I:IP/CALL=195.200.200.1" \endcode
///                   \b !Внимание! IP/PORT-адреса, содержащиеся в sid, не должны прописываться в данном поле, т.к. автоматически генерируются сервером.
///
///                - уточнение названия протокола - PROTOCOL (необязательно, только, если необходимо переопределить значение по-умолчанию):
/// \code
///                   P:<НАЗВАНИЕ>
/// \endcode
///                     \c <НАЗВАНИЕ> - название протокола (заглавные символы - протоколы общего назначения, заглавные символы + знак подчеркивания -
///                       для протоколов сборки TCP - tcpcat, заглавные символы + два знака подчеркивания - для протоколов внутри HTTP_): TCP, HTTP_, HTTP_DUMP__ <br>
///                   пример: \code
///                     "P:TCP"
///                     "P:HTTP_"
///                     "P:HTTP_WEBMAIL__"
///                           \endcode
///                   \b Данный атрибут должен использоваться для для протоколов внутри HTTP_ для уточнения типа данных.
///
///                - признак отбора - TOKEN:
/// \code
///                   T:<ИДЕНТИФИКАТОР>[/<ТИП>]=<ЗНАЧЕНИЕ>
/// \endcode
///                     \c <ИДЕНТИФИКАТОР> - уникальное числовое значение признака отбора <br>
///                     \c <ТИП> - тип найденного признака отбора: WORD (по умолчанию), области поиска для itf (LGN|ICQ|ISN|URLad|URL|DNad|DN|MED|ORIG|REF|T|H|C|A|mS|mA|F|S|Pr|PhN|PhI|PhE|PhB) <br>
///                     \c <ЗНАЧЕНИЕ> - строковое значение найденного вхождения признака <br>
///                   пример: \code "T:10/URL=mail.ru" \endcode
/// \param data_ct - медиа-тип (CONTENT-TYPE) в текстовом виде (строка с завершающим нулем), может быть nil
///           пример: \code "image/jpeg" \endcode
/// \param data_of - реальное имя файла (ORIGINAL_FILE) в текстовом виде (строка с завершающим нулем), может быть nil
///           пример: \code "http://index.php?ID=noname" \endcode
///
/// \par Регистрация аутентификационной информации:
///   data_type должен иметь значение \code "pwd_<протокол>" \endcode
///   пример: \code "pwd_http" \endcode
///   data_buf должен содержать две строки в виде:
///   \code
///            "user: <логин>"
///            "password: <пароль>"
///   \endcode
///   пример:
///   \code
///            "user: root"
///            "password: qwerty"
///   \endcode
///
/// \par Регистрация произвольной аутентификационной информации (контактных листов):
///   data_type должен иметь значение \code "acl_<протокол>" \endcode
///   пример: \code "acl_http" \endcode
///   data_buf должен содержать произвольное количество строк в любом виде:
///   пример:
///   \code
///            "ABONENT=xxx@mail.ru"
///            "CONTACT=yyy@mail.ru"
///            "NICKNAME=petya"
///            "CONTACT=zzz@mail.ru"
///            "NICKNAME=vasya"
///   \endcode
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_register_data)(void * stuff, PCatSID sid, gint data_flags, gconstpchar data_buf, gsize_t data_len, gconstpchar data_type, gconstpchar data_attrs, gconstpchar data_ct, gconstpchar data_of);

/// регистрация данных (вместе со служебным заголовком)
///
/// описание и поведение аналогично функции Tplug_callback_register_data (см. выше)
///
/// отличия:
/// \param svc_data_buf - указатель на буфер данных, содержащий служебный заголовок (заголовки) регистрируемых данных
/// \param svc_data_len - количество байт в буфере данных svc_data_buf
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_register_data_svc)(void * stuff, PCatSID sid, gint data_flags, gconstpchar data_buf, gsize_t data_len, gconstpchar data_type, gconstpchar data_attrs, gconstpchar data_ct, gconstpchar data_of, gconstpchar svc_data_buf, gsize_t svc_data_len);

/// регистрация данных (вместе со служебным заголовком и временными метками)
///
/// описание и поведение аналогично функции Tplug_callback_register_data_svc (см. выше)
///
/// отличия:
/// \param tv_start - указатель на временную метку начала регистрируемого события (может быть равен 0)
/// \param tv_stop  - указатель на временную метку завершения регистрируемого события (может быть равен 0)
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_register_data_svc_tv)(void * stuff, PCatSID sid, gint data_flags, gconstpchar data_buf, gsize_t data_len, gconstpchar data_type, gconstpchar data_attrs, gconstpchar data_ct, gconstpchar data_of, gconstpchar svc_data_buf, gsize_t svc_data_len, Ttimeval * tv_start, Ttimeval * tv_stop);

/// Добавление данных в кеш данных.
/// В случае удачного выполнения записывает в dhandle дескриптор помещенного блока.
///
/// Для выборки данных из кэша используется функция \ref Tplug_callback_data_cache_insert.
///
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param flags - набор флагов - не используется (зарезервировано)
/// \param buf - указатель на буфер данных
/// \param len - количество байт в буфере данных
/// \param[out] dhandle - дескриптор блока данных, занесенных в кэш
///
/// \return в случае успеха возвращает 0, в dhandle записывается дескриптор блока данных
/// \return в случае неудачи возвращает отрицательное значение
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_data_cache_insert)(void * stuff, gint flags, gconstpchar buf, gint len, void ** dhandle);

/// Получение данных из кеша данных.
/// В случае удачного выполнения извлекает данные из кэша и копирует их в буфер.
///
/// \note Для предварительного получения размера блока извлекаемых данных необходимо вызвать данную функцию с нулевым указателем на буфер.
///
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param dhandle - дескриптор извлекаемого блока данных внутри кэша данных (возвращается функцией \ref Tplug_callback_data_cache_insert)
/// \param flags - набор флагов - не используется (зарезервировано)
/// \param buf - указатель на буфер данных
/// \param len - количество байт в буфере данных
///
/// \return в случае успешного выполнения:
///   - если buf имеет нулевое значение, возвращает количество байт в блоке данных
///   - если buf имеет не нулевое значение, а len нулевое, извлекает блок из кэша данных, но не записывает данные в буфер
///   - иначе извлекает блок из кэша данных, записывает данные в буфер и возвращает количество байт в блоке данных
/// \return возвращает отрицательное значение в случае ошибки
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_data_cache_remove)(void * stuff, void * dhandle, gint flags, char * buf, gint len);

/// отбор данных
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param sid - адресный идентификатор данных (адреса и порты) - передается сервером при вызове функции \ref Tplug_session_begin
/// \param data_buf - указатель на буфер данных или указатель на строку с именем файла
/// \param data_len - количество байт в буфере данных
///
/// \return в случае, если данные не прошли отбор (необходимо удалить), возвращает нулевое значение (0)
/// \return в случае, если данные прошли отбор, возвращает ненулевое значение
///
/// !!! Внимание! Даннай функция считается устаревшей!!!
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_teri_match)(void * stuff, PCatSID sid, gconstpchar data_buf, gint data_len);

/// клонирование \ref TCatSID
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param source - указатель на экземпляр-источник
/// \param dest - указатель на экземпляр-приемник
///
/// функция копирует значения полей
///  - \c saddr
///  - \c daddr
///  - \c sport
///  - \c dport
///  - \c pid
///  - \c lid
///  .
/// структуры \c source в поля структуры \c dest
/// также создаются новые динамические данные в структуре dest (поле reserved - указатель на данные)
/// и инициализируются динамическими данными из структуры source (поле reserved)
///
/// экземпляры структур, на которые указывают source и dest, должны быть созданы вызывающим кодом
///
/// \note в последствии, данные структуры dest должны быть освобождены при помощи функции \ref Tplug_callback_sid_free
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_sid_clone)(void * stuff, PCatSID source, PCatSID dest);

/// клонирование признаков \ref TCatSID
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param source - указатель на экземпляр-источник
/// \param dest - указатель на экземпляр-приемник
///
/// функция копирует значения признаков из PacketInfo - поле reserved
/// структуры \c source в поля структуры \c dest
///
/// экземпляры структур, на которые указывают source и dest, должны быть созданы вызывающим кодом
///
/// \note в последствии, данные структуры dest должны быть освобождены при помощи функции \ref Tplug_callback_sid_free
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_sid_tokens_clone)(void * stuff, PCatSID source, PCatSID dest);

/// уничтожение \ref TCatSID
/// \param stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param sid - указатель на экземпляр структуры, инициализированной с помощью \ref Tplug_callback_sid_clone
///
/// функция производит освобождение динамических данных структуры sid (поле reserved - указатель на данные)
///
/// \note экземпляр структуры, на которую указывает sid, должен быть создан вызывающим кодом и инициализирован с помощью \ref Tplug_callback_sid_clone
///
/// \note функция не производит освобождение самой структуры типа \ref TCatSID, на которую указывает sid
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_sid_free)(void * stuff, PCatSID sid);

/// Создание файла.
///
/// В случае удачного выполнения записывает в fhandle дескрипор созданного файла.
///
/// Для записи в файл используется \ref Tplug_callback_file_write.
/// Для чтения из файла используется \ref Tplug_callback_file_read.
///
/// Для закрытия и удаления файла используется \ref Tplug_callback_file_close.
///
/// Для регистрации файла используется \ref Tplug_callback_register_data.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in flags - набор флагов - не используется (зарезервировано)
/// \param[out] fhandle - дескриптор созданного файла (используется функциями: \ref Tplug_callback_register_data,
///   \ref Tplug_callback_file_write, \ref Tplug_callback_file_read, \ref Tplug_callback_file_close).
///
/// \return в случае успеха возвращает 0, в fhandle записывается дескриптор созданного файла
/// \return в случае неудачи возвращает отрицательное значение
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_file_create)(void * stuff, gint flags, void ** fhandle);

/// запись данных в файл
/// производит запись данных в файл по определенной позиции
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in fhandle - дескриптор созданного файла (создается с помощью \ref Tplug_callback_file_create)
/// \param in buf - буфер для записи
/// \param in len - длина буфера для записи в байтах
/// \param in offset - стартовая позиция записи, задается в байтах от начала файла (значение -1 определяет текущую позицию)
///
/// \return в случае успеха возвращает 0
/// \return в случае неудачи возвращает отрицательное значение
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_file_write)(void * stuff, void * fhandle, void * buf, gsize_t len, gint64 offset);

/// чтение данных из файла
/// производит чтение данных из файла по определенной позиции
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in fhandle - дескриптор созданного файла (создается с помощью \ref Tplug_callback_file_create)
/// \param in buf - буфер для чтения
/// \param in len - длина буфера для чтения в байтах
/// \param in offset - стартовая позиция чтения, задается в байтах от начала файла (значение -1 определяет текущую позицию)
///
/// \return в случае успеха возвращает 0
/// \return в случае неудачи возвращает отрицательное значение
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_file_read)(void * stuff, void * fhandle, void * buf, gsize_t len, gint64 offset);

/// закрытие файла
/// освобождает дескриптор и удаляет файл
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in fhandle - дескриптор созданного файла (создается с помощью \ref Tplug_callback_file_create)
///
/// \return в случае успеха возвращает 0
/// \return в случае неудачи возвращает отрицательное значение
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_file_close)(void * stuff, void * fhandle);

/// \name функции СОРМ
///@{

/// Поиск известной сигнатуры данных в областях поиска spots буферов bufs (с длинами lens).
/// Если признак найден, вызывается функция обратного вызова cb (для каждого найденного признака) - в этом случае token->id содержит UIN
/// В режиме СОРМ сессия в случае успеха ставится на отбор по найденным признакам.
/// Если режим СОРМ отключен, функция работает в режиме уточняющего отбора, когда сессия в случае успеха на отбор по найденным признакам не ставится.
/// В режиме уточняющего отбора модуль должен регистрировать только данные, отобранные данной функцией (положительное возвращаемое значение).
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество буферов поиска
/// \param in bufs - массив буферов поиска
/// \param in lens - массив длин буферов поиска
/// \param in spots - массив областей поиска \ref teri_bis.h
/// \param in cb - адрес функции обратного вызова (\ref teri_bis.h)
/// \param in ud - первый параметр функции обратного вызова
///
/// !Внимание! В режиме СОРМ данную функцию можно использовать только внутри вызова plug_session_begin.
///
/// !Внимание! В режиме уточняющего отбора функция обратного вызова может быть ни разу не вызвана при положительном возвращаемом значении.
///
/// \return в случае успеха возвращается количество найденных вхождений
/// \return в случае неудачи возвращается отрицательное значение (код ошибки)
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_srm_teri_match)(void * stuff, gint count, gconstpointer* bufs, guint* lens, guint* spots, Tteri_bis_match_callback cb, void *ud);

/// Сложный отбор
/// Поиск известной сигнатуры данных в областях поиска spots буферов bufs (с длинами lens).
/// Если признак найден, вызывается функция обратного вызова cb (для каждого найденного признака) - в этом случае token->id содержит UINб token->id_ext содержит UIN_EXT
/// Если найдены признаки с флагами TERI_ID_EXT_RF_RAW_MAC/TERI_ID_EXT_RF_RAW_IP, то в режиме обработки TCP-сессии, сессия автоматически ставится на отбор по найденным признакам.
/// Если найдены признаки с флагами TERI_ID_EXT_RF_RAW_MAC/TERI_ID_EXT_RF_RAW_IP, то модуль должен произвести отправку данных с помощью функции plug_proto_ack_raw.
/// Если найдены признаки с флагами TERI_ID_EXT_RF_DECODED, вызывающий модуль должен декодировать и зарегистрировать данные.
/// В противном случае модуль должен отказаться от регистрации данных.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_create, и определяющий экземпляр обработчика
/// \param in flags - флаги режима поиска, константы COMPLEX_TERI_MATCH_XXX
/// \param in count - количество буферов поиска
/// \param in bufs - массив буферов поиска
/// \param in lens - массив длин буферов поиска
/// \param in spots - массив областей поиска \ref teri_bis.h
/// \param in cb - адрес функции обратного вызова (\ref teri_bis.h)
/// \param in ud - первый параметр функции обратного вызова
/// \param out has_rf_decoded - указатель на флаг того, что были найдены DECODED-признаки (адрес может быть равен 0)
/// \param out has_rf_raw - указатель на флаг того, что были найдены RAW-признаки (адрес может быть равен 0)
/// \param out out_uins	- указатель на массив значений UNI найденных признаков (адрес может быть равен 0) - значения актуальны вплоть до следующего вызова данной функции
/// \param out out_uins_ext - указатель на массив значений UNI_EXT найденных признаков (адрес может быть равен 0) - значения актуальны вплоть до следующего вызова данной функции
/// \param out out_uins_count - указатель на значение количества найденных признаков - размер массивов out_uins/out_uins_ext (адрес может быть равен 0) - значения актуальны вплоть до следующего вызова данной функции
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_begin.
///
/// \return в случае успеха возвращается количество найденных вхождений
/// \return в случае неудачи возвращается отрицательное значение (код ошибки)
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_complex_teri_match)(void * stuff, guint32 flags, gint count, gconstpchar* bufs, gint32* lens, guint32* spots, Tteri_bis_match_callback cb, void *ud, gboolean * has_rf_decoded, gboolean * has_rf_raw, guint32 ** out_uins, guint32 ** out_uins_ext, guint32 * out_uins_count);

/// "Заморозка" текущей сессии.
/// Вызывается из \ref Tplug_session_data.
/// В дальнейшем сессия должна быть "разморожена" с помощью \ref Tplug_callback_srm_freeze.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_data.
///
/// \return в случае успеха возвращается дескриптор "замороженной" сессии
/// \return в случае неудачи возвращается 0
///
typedef void * (MSCU_CALL_PREFIX * Tplug_callback_srm_freeze)(void * stuff);

/// "Разморозка" сессии с идентификатором id.
/// Если указаны один и более UIN, сессия уходит в отбор по данным UIN (uins).
/// После вызова данной функции, идентификатор id становится недействительным.
/// Сессия выходит из режима "потенциального" отбора ("сырые" пакеты сессии больше не накапливаются).
/// Пример: вызов plug_callback_srm_unfreeze(stuff, plug_callback_srm_freeze(stuff), 0, 0) - просто отменяет режим отбора для сессии.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in id - дескриптор сессии, возвращаемый функцией \ref Tplug_callback_srm_freeze
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
/// Связка plug_callback_srm_freeze/plug_callback_srm_unfreeze используется для отмены сорм-режима для сессии (по умолчанию данный режим используется
/// вызывающим приложением, данный режим предписывает хранить все пакеты сессии для случая, когда может сработать признак отбора)
/// Для отмены сорм-режима надо выполнить последовательный вызов plug_callback_srm_freeze, plug_callback_srm_unfreeze:
//    (*_tcpcat->plug_callback_srm_unfreeze)(_stuff, (*_tcpcat->plug_callback_srm_freeze)(_stuff), 0, 0);
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_unfreeze)(void * stuff, void * id, guint32 * uins, guint32 uins_count);

/// Проверка сессии на принадлежность к заданному типу
///
/// \param user_data - пользовательские данные.
/// \param buf, len - буфер, содержащий начальные данные новой сессии первого направления
/// \param buf2, len2 - буфер, содержащий начальные данные новой сессии второго направления (если второго направления нет, buf2 = nil)
///
/// \return если обработчик "опознал" сессию, необходимо вернуть ненулевое значение
/// \return если обработчик не "опознал" сессию, необходимо вернуть нулевое значение
///
typedef gboolean (MSCU_CALL_PREFIX * Ttcpcat_spy_callback)(gpointer user_data, gconstpchar buf, int len, gconstpchar buf2, int len2);

/// Постановка задания на слежение за активностью сессии по заданным параметрам (IP-адрес/TCP-порт/IP-адрес/TCP-порт).
/// Если задана функция обратного вызова, дополнительно производится проверка на содержимое сессии
/// Все пакеты такой сессии ставятся на отбор по заданному списку UIN (uins).
/// Возможны следующие варианты:
///   addr1, port1, addr2, port2
///   addr1, port1, addr2
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество квадриг IP-адрес/TCP-порт/IP-адрес/TCP-порт
/// \param in addr1 - массив IP-адресов (связан с port1), может быть равен 0
/// \param in port1 - массив TCP-портов (связан с addr1), может быть равен 0
/// \param in addr2 - массив IP-адресов (связан с port2), может быть равен 0
/// \param in port2 - массив TCP-портов (связан с addr2), может быть равен 0
/// \param in cb - адрес функции обратного вызова
/// \param in ud - первый параметр функции обратного вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_add_spy)(void * stuff, gint count, guint32* addr1, guint16* port1, guint32* addr2, guint16* port2, Ttcpcat_spy_callback cb, gpointer ud, guint32 * uins, guint32 uins_count);

/// Постановка задания на слежение за активностью сессии по заданным параметрам (IP-адрес/TCP-порт/IP-адрес/TCP-порт).
/// Если задана функция обратного вызова, дополнительно производится проверка на содержимое сессии
/// Все пакеты такой сессии ставятся на отбор по заданному списку пар UIN/UIN_EXT (uins).
/// Возможны следующие варианты:
///   addr1, port1, addr2, port2
///   addr1, port1, addr2
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество квадриг IP-адрес/TCP-порт/IP-адрес/TCP-порт
/// \param in addr1 - массив IP-адресов (связан с port1), может быть равен 0
/// \param in port1 - массив TCP-портов (связан с addr1), может быть равен 0
/// \param in addr2 - массив IP-адресов (связан с port2), может быть равен 0
/// \param in port2 - массив TCP-портов (связан с addr2), может быть равен 0
/// \param in cb - адрес функции обратного вызова
/// \param in ud - первый параметр функции обратного вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_ext - массив значений UIN_EXT, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_add_spy_ex)(void * stuff, gint count, guint32* addr1, guint16* port1, guint32* addr2, guint16* port2, Ttcpcat_spy_callback cb, gpointer ud, guint32 * uins, guint32 * uins_ext, guint32 uins_count);

/// Постановка задания на слежение за активностью сессии по заданным параметрам (IPv6-адрес/TCP-порт/IPv6-адрес/TCP-порт).
/// Если задана функция обратного вызова, дополнительно производится проверка на содержимое сессии
/// Все пакеты такой сессии ставятся на отбор по заданному списку UIN (uins).
/// Возможны следующие варианты:
///   addr1, port1, addr2, port2
///   addr1, port1, addr2
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество квадриг IP-адрес/TCP-порт/IP-адрес/TCP-порт
/// \param in addr1 - массив IPv6-адресов (связан с port1), может быть равен 0
/// \param in port1 - массив TCP-портов (связан с addr1), может быть равен 0
/// \param in addr2 - массив IPv6-адресов (связан с port2), может быть равен 0
/// \param in port2 - массив TCP-портов (связан с addr2), может быть равен 0
/// \param in cb - адрес функции обратного вызова
/// \param in ud - первый параметр функции обратного вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_add_spy_ipv6)(void * stuff, gint count, guint8 ** addr1, guint16* port1, guint8 ** addr2, guint16* port2, Ttcpcat_spy_callback cb, gpointer ud, guint32 * uins, guint32 uins_count);

/// Постановка задания на слежение за активностью сессии по заданным параметрам (IPv6-адрес/TCP-порт/IPv6-адрес/TCP-порт).
/// Если задана функция обратного вызова, дополнительно производится проверка на содержимое сессии
/// Все пакеты такой сессии ставятся на отбор по заданному списку UIN/UIN_EXT (uins).
/// Возможны следующие варианты:
///   addr1, port1, addr2, port2
///   addr1, port1, addr2
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество квадриг IP-адрес/TCP-порт/IP-адрес/TCP-порт
/// \param in addr1 - массив IPv6-адресов (связан с port1), может быть равен 0
/// \param in port1 - массив TCP-портов (связан с addr1), может быть равен 0
/// \param in addr2 - массив IPv6-адресов (связан с port2), может быть равен 0
/// \param in port2 - массив TCP-портов (связан с addr2), может быть равен 0
/// \param in cb - адрес функции обратного вызова
/// \param in ud - первый параметр функции обратного вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_ext - массив значений UIN_EXT, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_add_spy_ipv6_ex)(void * stuff, gint count, guint8 ** addr1, guint16* port1, guint8 ** addr2, guint16* port2, Ttcpcat_spy_callback cb, gpointer ud, guint32 * uins, guint32 * uins_ext, guint32 uins_count);

/// Постановка текущей сессии на отбор по заданному списку UIN (uins).
/// Вызывается из \ref Tplug_session_data.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_begin.
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_make_urgent)(void * stuff, guint32 * uins, guint32 uins_count);

/// Постановка текущей сессии на сложный отбор по заданному списку UIN/EXT (uins).
/// Вызывается из \ref Tplug_session_data.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in uins - массив значений UIN, по которым сессия должна уйти в отбор
/// \param in uins_ext - массив значений UIN_EXT, по которым сессия должна уйти в отбор
/// \param in uins_count - количество элементов в массиве
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_begin.
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_complex_teri_make_urgent)(void * stuff, guint32 * uins, guint32 * uins_ext, guint32 uins_count);

/// 2010-09-16
/// Поиск известной сигнатуры данных в областях поиска spots буферов bufs (с длинами lens).
/// Если признак найден, вызывается функция обратного вызова cb (для каждого найденного признака) - в этом случае token->id содержит UIN
/// Декларирование тэга распределенной обработки в случае успешного результата поиска.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in count - количество буферов поиска
/// \param in bufs - массив буферов поиска
/// \param in lens - массив длин буферов поиска
/// \param in spots - массив областей поиска \ref teri_bis.h
/// \param in cb - адрес функции обратного вызова (\ref teri_bis.h)
/// \param in ud - первый параметр функции обратного вызова
/// \param in tag_buf - буфер, содержащий тэг
/// \param in tag_len - буфера, содержащего тэг, в байтах
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_data.
///
/// \return в случае успеха возвращается количество найденных вхождений
/// \return в случае неудачи возвращается отрицательное значение (код ошибки)
///
typedef gint (MSCU_CALL_PREFIX * Tplug_callback_srm_teri_match_tag)(void * stuff, gint count, gconstpointer* bufs, guint* lens, guint* spots, Tteri_bis_match_callback cb, void *ud, gconstpointer tag_buf, guint tag_len);

/// 2010-09-16
/// Установка тэга распределенной обработки для текущей сессии.
/// Вызывается из \ref Tplug_session_data.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in tag_buf - буфер, содержащий тэг
/// \param in tag_len - буфера, содержащего тэг, в байтах
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_data.
///
/// \return в случае успеха возвращается дескриптор "замороженной" сессии
/// \return в случае неудачи возвращается 0
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_set_tag)(void * stuff, gconstpointer tag_buf, guint tag_len);

/// 2012-12-25
/// Добавление вторичного признака в подсистему отбора.
/// Включенный флаг token_is_indirect используется для добавления признака автоподстановки (когда существующий признак инициирует добавление активности новых фигурантов).
/// Выключенный флаг token_is_indirect используется для добавления признака привязки (когда существующий признак меняет свое значение в процессе изменения активности).
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in token_buf - буфер с данными признака
/// \param in token_len - длина буфера с данными признака
/// \param in token_spot - областей поиска \ref teri_bis.h
/// \param in token_is_indirect - тип признака: 0 - не косвенный (приоритет token->prio найденного признака данного типа не равен 2), !0 - косвенный (приоритет token->prio найденного признака данного типа равен 2, такой признак не может в дальнейшем порождать аналогичные вызовы)
/// \param in uins - массив значений UIN, к которым относится добавляемый признак
/// \param in uins_count - количество элементов в массиве uins
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_data.
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_set_secondary_token)(void * stuff, gconstpointer token_buf, guint token_len, guint token_spot, gboolean token_is_indirect, guint32 * uins, guint32 uins_count);

/// 2016-11-16
/// Добавление вторичного признака в подсистему отбора.
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in filter_item - структура, содержащая ip-адреса (1 или 2)
/// \param in tv - TimeStamp
/// \param in unis - массив значений UNI, к которым относится добавляемый признак
/// \param in unis_count - количество элементов в массиве uins
///
/// !Внимание! Данную функцию можно использовать только внутри вызова plug_session_data.
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_srm_set_secondary_token2)(void * stuff, S10G_FILTER_ITEM_STRUCT_2 * filter_item, Ttimeval* tv, guint32* unis, gsize_t unis_count);

/// 2014-04-23
/// Поиск зарегистрированного поля
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in name - название поля для поиска
///
/// !Внимание! Данную функцию рекомендуется использовать только внутри вызова plug_session_data.
///
/// \return в случае успеха возвращается значение зарегистрированного поля (фактически - адрес области в памяти)
/// \return в случае неудачи возвращается 0
///
typedef gpointer (MSCU_CALL_PREFIX * Tplug_callback_find_field_info)(void * stuff, gconstpchar name);

/// 2015-02-16
/// Регистрация поля
/// После создания нового поля, его можно использовать для взаимодействия между обработчиками:
///   один обработчик с помощью данной функции регистрирует адрес на свои данные (функцию или перменную)
///   другой с помощью функции plug_proto_find_field_info получает этот адрес для использования
///
/// \param in stuff - параметр, передаваемый при вызове функций \ref Tplug_register, и определяющий текущий контекст вызова
/// \param in name - название поля для поиска
/// \param in value - значение поля (адрес), возвращаемое функцией поиска
///
typedef void (MSCU_CALL_PREFIX * Tplug_callback_register_field_info)(void * stuff, gconstpchar name, gpointer value);

/// @}

/// \struct TTCPCATStandartFunctions
/// набор стандартных функций обратного вызова
STRUCT_PACKED_BEGIN
struct STRUCT_PACKED_ATTRIBUTE TTCPCATStandartFunctions {
  unsigned int cbSize; ///< размер данной структуры

  /// \name функции общего назначения
  ///@{
  Tplug_callback_add_message           plug_callback_add_message;
  Tplug_callback_register_data         plug_callback_register_data;
  Tplug_callback_data_cache_insert     plug_callback_data_cache_insert;
  Tplug_callback_data_cache_remove     plug_callback_data_cache_remove;
  Tplug_callback_teri_match            plug_callback_teri_match;
  Tplug_callback_sid_clone             plug_callback_sid_clone;
  Tplug_callback_sid_free              plug_callback_sid_free;
  Tplug_callback_file_create           plug_callback_file_create;
  Tplug_callback_file_write            plug_callback_file_write;
  Tplug_callback_file_close            plug_callback_file_close;
  ///@}

  /// \name функции СОРМ
  ///@{
  Tplug_callback_srm_teri_match        plug_callback_srm_teri_match;
  Tplug_callback_srm_freeze            plug_callback_srm_freeze;
  Tplug_callback_srm_unfreeze          plug_callback_srm_unfreeze;
  Tplug_callback_srm_add_spy           plug_callback_srm_add_spy;
  Tplug_callback_srm_make_urgent       plug_callback_srm_make_urgent;
  ///@}

  /// \name функции поиска
  ///@{
  Tenum_file_find                      enum_file_find;
  Tenum_service_tcp_find               enum_service_tcp_find;
  Tenum_service_udp_find               enum_service_udp_find;
  Tenum_mime_find                      enum_mime_find;
  Tenum_ip_find                        enum_ip_find;
  Tenum_oui_find                       enum_oui_find;
  Tenum_pid_find                       enum_pid_find;
  ///@}

  /// \name функции СОРМ - 2010-09-16
  ///@{
  Tplug_callback_srm_teri_match_tag    plug_callback_srm_teri_match_tag;
  Tplug_callback_srm_set_tag           plug_callback_srm_set_tag;
  ///@}

  /// \name функции общего назначения - 2012-05-02
  ///@{
  Tplug_callback_file_read                plug_callback_file_read;
  ///@}

  /// \name функции СОРМ - 2012-12-25
  ///@{
  Tplug_callback_srm_set_secondary_token  plug_callback_srm_set_secondary_token;
  ///@}

  /// \name функции из swine_api.h - 2014-04-23
  ///@{
  Tplug_callback_find_field_info          plug_callback_find_field_info;
  ///@}

  /// \name функция регистрация вместе со служебным заголовком - 2014-06-27
  ///@{
  Tplug_callback_register_data_svc        plug_callback_register_data_svc;
  ///@}

  /// \name функция регистрация вместе со служебным заголовком и временными метками - 2014-07-30
  ///@{
  Tplug_callback_register_data_svc_tv     plug_callback_register_data_svc_tv;
  ///@}

  /// \name функции из swine_api.h - 2015-02-17
  ///@{
  Tplug_callback_register_field_info          plug_callback_register_field_info;
  ///@}

	/// 2016-11-13
  Tplug_callback_sid_tokens_clone             plug_callback_sid_tokens_clone;

  /// \name функции СОРМ - 2016-11-16
  ///@{
  Tplug_callback_srm_set_secondary_token2		plug_callback_srm_set_secondary_token2;
  ///@}

  /// \name функции СОРМ - 2016-12-21
  ///@{
	Tplug_callback_srm_add_spy_ipv6           plug_callback_srm_add_spy_ipv6;
  ///@}
	// добавлено 2017-06-02
  Tplug_callback_complex_teri_match				plug_callback_complex_teri_match;
  Tplug_callback_complex_teri_make_urgent	plug_callback_complex_teri_make_urgent;

  /// \name функции СОРМ - 2017-06-17
  ///@{
  Tplug_callback_srm_add_spy_ex           plug_callback_srm_add_spy_ex;
	Tplug_callback_srm_add_spy_ipv6_ex      plug_callback_srm_add_spy_ipv6_ex;
  ///@}
};
STRUCT_PACKED_END
/// указатель на структуру TTCPCATStandartFunctions
typedef TTCPCATStandartFunctions* PTCPCATStandartFunctions;

/// \}

/// \defgroup tcpcat_exports Экспортируемые функции
/// \{
/// Данный раздлел описывате типы экспортируемых функций для реализации внутри плагина

/// регистратор нового обработчика: экспортное имя - \b "tcpcat_plug_register". <br>
/// функция должна заполнить следующие строковые буферы (каждый размером TCPCAT_STR_SIZE)
/// определенными значениями (строками с завершающим нулем, например, с помощью функции strncpy):
///   \c version, \c name, \c short_name. \c filter_name, \c description, \c alt_ports, \c alt_tokens
/// \param version - версия плагина (например, "0.4.1")
/// \param name -        "длинное" имя протокола, данные которого способен
///               обрабатывать данный плагин, например: "HyperText Transfer Protocol"
///               синтаксис - не ограничен, одна строка, желательно, длиной до 40-60 символов
/// \param short_name -  "короткое" имя протокола, данные которого способен
///               обрабатывать данный плагин, например: "HTTP"
///               синтаксис - не ограничен, прописные буквы, желательно одним-двумя короткими словами
/// \param filter_name - "внутреннее" имя протокола, данные которого способен
///               обрабатывать данный плагин, например: "http"
///               синтаксис - только строчные буквы и символы подчеркивания, желательно одним коротким словом
/// \param description - описание плагина (например, "Обработчик HTTP + WebMail. Обрабатываемые версии HTTP: 1.0, 1.1. Обработка WebMail - mail.ru и др.")
///               синтаксис - не ограничен, возможны символы возврата каретки и перевода строки (многострочное описание)
/// \param alt_ports   - для альтернативной идентификации: список TCP-портов, соответствующих данному протоколу
///               формат: [!]<значение>;[!]<значение>;...[!]<значение>, где знак ! - необязательный символ, задающий порт исключения (сессия с таким портом никогда не попадет на вход данному обработчику)
///               например: "80;3128;8080;!21;!25"
/// \param alt_tokens  - для альтернативной идентификации: список идентификаторов, соответствующих данному протоколу
///               формат: <значение>;<значение>;...<значение>, например: "GET\[\x20\x07];POST\[\x20\x07]"
///
/// \param TCPCATStandartFunctions - адрес на структуру, содержащую адреса стандартных функций обратного вызова TCPCAT (TTCPCATStandartFunctions).
///   Необходимо запомнить во внутренней переменной адрес структуры стандартных функций (сама структура располагается
///     внутри ядра и хранится все время жизни процесса)
///
/// \param TCPCATStuff - первый параметр для стандартных функций обратного вызова TCPCAT (TTCPCATStandartFunctions).
///   Необходимо запомнить во внутренней переменной и использовать при вызове стандартных функций обратного вызова
///
/// \return возвращает 0 в случае успеха
/// \return если библиотека не смогла нормально загрузиться, должна возратить ненулевое значение, чтобы сервер выгрузил библиотеку
typedef int (MSCU_CALL_PREFIX * Tplug_register)(PTCPCATStandartFunctions TCPCATStandartFunctions, void * TCPCATStuff,
                                        char * version, char * name, char * short_name, char * filter_name, char * description,
                                        char * alt_ports, char * alt_tokens);

/// дерегистратор обработчика: экспортное имя - \b "tcpcat_plug_unregister". <br>
/// вызывается при завершении работы с целью дать обработчику освободить занятые ресурсы перед выгрузкой
///
typedef void (MSCU_CALL_PREFIX * Tplug_unregister)();

/// регистрация параметров настройки модуля: экспортное имя - \b "tcpcat_plug_config_register". <br>
///
/// \param owner - корневой узел настроек для данного модуля
///
/// \note при регистрации параметров необходимо использовать функции prefs_XXX (обратный вызов)
///
/// \return функция не возвращает значения
///
typedef void (MSCU_CALL_PREFIX * Tplug_config_register)(preference_p owner);

/// установка флагов обработки сесии: экспортное имя - \b "tcpcat_plug_setup_flags". <br>
/// вызывается при запуске нового сеанса обработки
///
/// \param[out] flags - набор флагов, определяющих режим обработки открываемых сессий значения флагов используются в режиме, когда не вызывается "tcpcat_plug_session_begin":
///       - OUT: флаг DD_STREAMED_DATA определяет режим обработки сессии (задается в функции plug_session_begin)
///            - флаг отсутствует (0) - сборка сессии в режиме DD_FIXED_DATA (полная сборка, затем передача на обработку)
///            - флаг присутствует (1) - сборка сессии в поточном режиме (по частям)
///                          при вызове функции plug_session_data флаг DD_FIXED_DATA будет присутствовать
///                          только при передаче последнего блока данных сессии
///            .
///           значение по-умолчанию - 0
///       - OUT: флаг DD_COMPLEX_BUFFER предписывает вызывающему передавать в дальнейшем данные сеанса в сложном формате:
///            - флаг отсутствует (0) - данные в буфере от двух направлений "склеиваются" без указаний направления
///            - флаг присутствует (1) - перед каждым блоком данных в буфере располагается заголовок (4 байта - host-формат):
///                          - старший бит - 0 - прямое направление / 1 - обратное направление
///                          - младшие 31 бит - длина передаваемого блока данных в байтах (размер данного заголовка не учитывается )
///            .
///            значение по-умолчанию - 0
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///       - OUT: флаг DD_COMPLEX_BUFFER_BYTES используется совместно с флагом DD_COMPLEX_BUFFER и предписывает вызывающему
///            передавать в дальнейшем данные сеанса в сложном формате:
///            - флаг отсутствует (0) - заголовок, передавемый перед блоком данных имеет размер 32 бита / 4 байта (описан выше)
///            - флаг присутствует (1) - заголовок, передавемый перед блоком данных имеет размер 5 байт:
///                          - первый байт - 0 - прямое направление / не 0 - обратное направление
///                          - последние 4 байта - длина передаваемого блока данных в байтах (host-формат, размер данного заголовка не учитывается)
///            .
///            значение по-умолчанию - 0
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///       - OUT: флаг DD_LONG_TTL используется при принятии решения о закрытии сессии при отсутствии ее активности
///            - флаг отсутствует (0) - сессия имеет стандартное время жизни
///                                   максимальное время жизни определяется параметром
///                                   "Время отсутствия активности сессии"
///            - флаг присутствует (1) - сессия имеет увеличенное время жизни
///                                    максимальное время жизни определяется параметром
///                                    "Время отсутствия активности длительной сессии"
///            .
///            значение по-умолчанию - 0
///
typedef void (MSCU_CALL_PREFIX * Tplug_setup_flags)(gint32 * flags);

/// Открытие новой сессии: экспортное имя - \b "tcpcat_plug_session_begin". <br>
/// В данной функции плагину предлагается инициализировать контекст обработки новой сессии.
///
/// \param sid - идентификатор новой сессии (адреса и порты).
///       Рекомендуется сохранять данный параметр если в дальнейшем предполагается вызов \ref Tplug_callback_register_data
/// \param buf, len - буфер, содержащий начальные данные новой сессии первого направления
/// \param buf2, len2 - буфер, содержащий начальные данные новой сессии второго направления (если второго направления нет, buf2 = nil)
/// \param[in,out] flags  - набор флагов, определяющих режим обработки открываемой сессии:
///       - OUT: флаг DD_STREAMED_DATA определяет режим обработки сессии (задается в функции plug_session_begin)
///            - флаг отсутствует (0) - сборка сессии в режиме DD_FIXED_DATA (полная сборка, затем передача на обработку)
///            - флаг присутствует (1) - сборка сессии в поточном режиме (по частям)
///                          при вызове функции plug_session_data флаг DD_FIXED_DATA будет присутствовать
///                          только при передаче последнего блока данных сессии
///            .
///           значение по-умолчанию - 0
///       - OUT: флаг DD_COMPLEX_BUFFER предписывает вызывающему передавать в дальнейшем данные сеанса в сложном формате:
///            - флаг отсутствует (0) - данные в буфере от двух направлений "склеиваются" без указаний направления
///            - флаг присутствует (1) - перед каждым блоком данных в буфере располагается заголовок (4 байта - host-формат):
///                          - старший бит - 0 - прямое направление / 1 - обратное направление
///                          - младшие 31 бит - длина передаваемого блока данных в байтах (размер данного заголовка не учитывается )
///            .
///            значение по-умолчанию - 0
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///       - OUT: флаг DD_COMPLEX_BUFFER_BYTES используется совместно с флагом DD_COMPLEX_BUFFER и предписывает вызывающему
///            передавать в дальнейшем данные сеанса в сложном формате:
///            - флаг отсутствует (0) - заголовок, передавемый перед блоком данных имеет размер 32 бита / 4 байта (описан выше)
///            - флаг присутствует (1) - заголовок, передавемый перед блоком данных имеет размер 5 байт:
///                          - первый байт - 0 - прямое направление / не 0 - обратное направление
///                          - последние 4 байта - длина передаваемого блока данных в байтах (host-формат, размер данного заголовка не учитывается)
///            .
///            значение по-умолчанию - 0
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///       - OUT: флаг DD_LONG_TTL используется при принятии решения о закрытии сессии при отсутствии ее активности
///            - флаг отсутствует (0) - сессия имеет стандартное время жизни
///                                   максимальное время жизни определяется параметром
///                                   "Время отсутствия активности сессии"
///            - флаг присутствует (1) - сессия имеет увеличенное время жизни
///                                    максимальное время жизни определяется параметром
///                                    "Время отсутствия активности длительной сессии"
///            .
///            значение по-умолчанию - 0
///
/// \return возвращаемое значение - контекст обработки - хранится сервером и используется для его передачи функциям плагина \ref Tplug_session_data, \ref Tplug_session_end
///
/// \return если обработчик "опознал" сессию, но решил отказаться от дальнейшей обработки данной сессии, то должен вернуть значение TCPCAT_RESULT_DISCARD в этом случае сессия будет закрыта
///
/// \return если обработчик не "опознал" сессию, то должен вернуть значение nil (NULL)
///
typedef void * (MSCU_CALL_PREFIX * Tplug_session_begin)(PCatSID sid, const guint8* buf, int len, const guint8* buf2, int len2, int * flags);

/// обработка данных сессии: экспортное имя - \b "tcpcat_plug_session_data". <br>
///
/// \param[in,out] shandle - ссылка на контекст обработки (возвращается функцией \ref Tplug_session_begin)
///   - если *shandle == 0, то это означает, что tcpcat_plug_session_begin вызвана не была и необходимо
///     создать контекст обработки и записать его в *shandle
///   - если при выходе необходимо закрыть/удалить контекст обработки, то после удаления необходимо также
///     обнулить контекст по ссылке (*shandle = 0)
/// \param si - информация о сессии
/// \param[in,out] flags - набор флагов, определяющих:
///       - IN:  тип источника (буфер/файл) (BLOB-поле/файл) (флаги типа DD_XXX)
///       - IN:  направление передачи - прямое/обратное - флаг DD_DIRECTION_REVERSE
///       - IN:  режим обработки сессии - DD_STREAMED_DATA
///            - флаг отсутствует (0) - сборка сессии в обычном режиме (полная сборка, затем передача на обработку)
///            - флаг присутствует (1) - сборка сессии в поточном режиме (по частям)
///                          при вызове функции plug_session_data флаг DD_FIXED_DATA будет присутствовать
///                          только при передаче последнего блока данных сессии
///            .
///       - IN:  правила обработки - DD_FIXED_DATA
///            - флаг отсутствует (0) - блок данных сессии - не последний (возможны последующие вызовы данной функции)
///            - флаг присутствует (1) - блок данных сессии - последний
///       - IN:  DD_COMPLEX_BUFFER - тип передаваемого буфера (присутствует, если сессия создавалась с данным флагом)
///            - флаг отсутствует (0) - данные в буфере от двух направлений "склеиваются" без указаний направления
///            - флаг присутствует (1) - перед каждым блоком данных в буфере располагается заголовок (4 байта - host-формат):
///                          старший бит - 0 - прямое направление / 1 - обратное направление
///                          младшие 31 бит - длина передаваемого блока данных в байтах (размер данного заголовка не учитывается )
///            .
///            \b Внимание! В определенных случаях допускается отсутствие данного флага.
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///       - IN:  флаг DD_COMPLEX_BUFFER_BYTES используется совместно с флагом DD_COMPLEX_BUFFER
///            - флаг отсутствует (0) - заголовок, передавемый перед блоком данных имеет размер 32 бита / 4 байта (описан выше)
///            - флаг присутствует (1) - заголовок, передавемый перед блоком данных имеет размер 5 байт:
///                          первый байт - 0 - прямое направление / не 0 - обратное направление
///                          последние 4 байта - длина передаваемого блока данных в байтах (host-формат, размер данного заголовка не учитывается)
///            !!!2014-02-27 устаревшая функция - будет удалена в ближайших версиях!!!
///
/// \param buf, len - буфер с данными
///            карта направлений и карта меток времени:
///              по адресу buf + ((len + 3) & ~3) - выравнивание до 32 бит (4 байт) - расположены следующие структуры:
///                [4]    - размер карты направлений - смещение карты меток времени (в байтах) - 32-битное слово (4 байта - host-формат)
///                [8]*N  - карта направлений - массив элементов типа TDirectionMapItem (см. описание), содержащий, как минимум, один нулевой элемент
///                         карта направлений завершается нулевым элементом TDirectionMapItem (все поля данной структуры равны 0)
///                [12]*M - карта меток времени - массив элементов типа TTimestampMapItem (см. описание), содержащий, как минимум, один нулевой элемент
///                         карта направлений завершается нулевым элементом TTimestampMapItem (все поля данной структуры равны 0)
///              карта направлений определяет направление передачи данных из буфера buf
///              карта меток времени определяет время передачи данных из буфера buf
///              размер карты направлений, карта направлений и карта меток времени не входят в len
///              карту направлений и карту меток времени МОЖНО модифицировать
///
/// Особые случаи: вызов функции при buf==0, len==0 при наличии во flags бита DD_FIXED_DATA означает, что сессия завершилась по завершающим
///   FIN/RST или таймауту, а не по закрытию источника данных.
/// Особые случаи: вызов функции при buf==0, len<0 при отсутствии во flags бита DD_FIXED_DATA означает, сколько байт было реально пропущено
///   в данной сессии после прошлого вызова данной функции с возвращенным значением, равным TCPCAT_RESULT_SKIP_ALL или (len + TCPCAT_RESULT_SKIP_BASE).
///
/// \return возвращаемое значение
///   - при DD_FIXED_DATA: 1
///     - (> 0) и (< len) - обработана только часть входного буфера, оставшаяся часть будет передана сразу же при последующем повторном вызове
///     - len (должен обработать все данные)
///             <b> !необходимо закрыть контекст обработки сессии, так как функция \ref Tplug_session_end вызвана не будет! </b>
///     - TCPCAT_RESULT_DISCARD(2147483647) ($7fffffff  в аболютном значении) - отказ от дальнейшей обработки данной сессии
///             <b> !необходимо закрыть контекст обработки сессии, так как функция \ref Tplug_session_end вызвана не будет! </b>
///     - TCPCAT_RESULT_ESCAPE(2147483646) ($7ffffffe  в аболютном значении) - отказ от дальнейшей обработки данной сессии в пользу другого обработчика
///             <b> !необходимо закрыть контекст обработки сессии, так как функция \ref Tplug_session_end вызвана не будет! </b>
///   - при DD_FIXED_DATA: 0
///     - > 0 - количество обработанных данных
///             если возращаемое значение больше или равно TCPCAT_RESULT_CROP_AND_NEED_BASE, то количество обработанных данных равно (res - TCPCAT_RESULT_SKIP_BASE),
///               а также требуется еще -1 байт к оставшимся в буфере перед следующим вызовом данной функции
///     - < 0 - требуемое количество дополнительных данных;
///             если возращаемое значение больше по модулю TCPCAT_RESULT_SKIP_BASE, пропускаются данные входного буфера,
///               а также следующие (res - TCPCAT_RESULT_SKIP_BASE) байт, где res - возвращаемое значение,
///               данная функция будет вызвана не более одного раза со значениями параметров buf==0, len<0 и отсутствии во flags бита DD_FIXED_DATA, где len в абсолютном значении будет определять количество реально пропущенных байт
///     - TCPCAT_RESULT_FINISH(-2147483648) ($80000000 в аболютном значении) - приказ серверу собирать сессию до конца (в данном направлении???)
///     - TCPCAT_RESULT_SKIP_ALL(-2147483647) ($80000001 в аболютном значении) - приказ серверу пропустить данные сессии до конца (в данном направлении???)
///               данная функция будет вызвана не более одного раза со значениями параметров buf==0, len<0 и отсутствии во flags бита DD_FIXED_DATA, где len в абсолютном значении будет определять количество реально пропущенных байт
///     - TCPCAT_RESULT_DISCARD(2147483647) ($7fffffff  в аболютном значении) - отказ от дальнейшей обработки данной сессии
///             <b> !необходимо закрыть контекст обработки сессии, так как функция \ref Tplug_session_end вызвана не будет! </b>
///     - TCPCAT_RESULT_ESCAPE(2147483646) ($7ffffffe  в аболютном значении) - отказ от дальнейшей обработки данной сессии в пользу другого обработчика
///             <b> !необходимо закрыть контекст обработки сессии, так как функция \ref Tplug_session_end вызвана не будет! </b>
///
typedef int (MSCU_CALL_PREFIX * Tplug_session_data)(void ** shandle, PCatSessionInfo si, int * flags, const guint8* buf, int len);

/// закрытие сессии: экспортное имя - \b "tcpcat_plug_session_end". <br>
/// \param shandle - контекст обработки (возвращается функцией \ref Tplug_session_begin)
///
/// Вызывается, когда необходимо закрыть контекст обработки завершенной сессии.
/// В данной функции плагину предлагается финализировать служебные
/// данные, освободить выделенную память и т.д.
///
typedef void (MSCU_CALL_PREFIX * Tplug_session_end)(void * shandle);

/// фоновая обработка: экспортное имя - \b "tcpcat_plug_perform". <br>
///
/// \param command - действие
///
/// Выполнение дествия (зависит от command)
///  - PERFORM_COMMAND_BUILD - вызывается для построения дополнительных элементов обработчиков (вызов функции register_field_info)
///  - PERFORM_COMMAND_BIND - вызывается для связывание обработчиков (вызов функции find_field_info)
///  - PERFORM_COMMAND_START - вызывается при запуске нового сеанса обработки
///  - PERFORM_COMMAND_STOP - вызывается при завершении очередного сеанса обработки
///  - PERFORM_COMMAND_IDLE - дает возможность модулю производить фоновую обработку (вызывается с периодом, равным 1 сек или 100 мсек)

///  - PERFORM_COMMAND_FLUSH - завершение обработки с регистрацией данных ("мягкое" завершение)
///  - PERFORM_COMMAND_SUSPEND - приостановка обработки, резервирование временных меток
///  - PERFORM_COMMAND_RESUME - возобновление обработки, корректировка временных меток, зарезервированных при последнем PERFORM_COMMAND_SUSPEND
///
/// \return функция возвращает true в случае удачного выполнения, иначе - false (в таком случае необходимо с помощью plug_callback_add_message вывести сообщение, описывающее ошибку)
///
typedef gboolean (MSCU_CALL_PREFIX * Ttcpcat_plug_perform)(gint command);

/// \}

/// @}

#endif